<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Sorted Containers · DataStructures.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DataStructures.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">DataStructures.jl</a></li><li><a class="toctext" href="deque.html">Deque</a></li><li><a class="toctext" href="circ_buffer.html">CircularBuffer</a></li><li><a class="toctext" href="circ_deque.html">CircularDeque</a></li><li><a class="toctext" href="stack_and_queue.html">Stack and Queue</a></li><li><a class="toctext" href="priority-queue.html">Priority Queue</a></li><li><a class="toctext" href="accumulators.html">Accumulators and Counters</a></li><li><a class="toctext" href="disjoint_sets.html">Disjoint Sets</a></li><li><a class="toctext" href="heaps.html">Heaps</a></li><li><a class="toctext" href="ordered_containers.html">OrderedDicts and OrderedSets</a></li><li><a class="toctext" href="default_dict.html">DefaultDict and DefaultOrderedDict</a></li><li><a class="toctext" href="trie.html">Trie</a></li><li><a class="toctext" href="linked_list.html">Linked List</a></li><li><a class="toctext" href="intset.html">DataStructures.IntSet</a></li><li class="current"><a class="toctext" href="sorted_containers.html">Sorted Containers</a><ul class="internal"><li><a class="toctext" href="#Tokens-for-Sorted-Containers-1">Tokens for Sorted Containers</a></li><li><a class="toctext" href="#Constructors-for-Sorted-Containers-1">Constructors for Sorted Containers</a></li><li><a class="toctext" href="#Complexity-of-Sorted-Containers-1">Complexity of Sorted Containers</a></li><li><a class="toctext" href="#Inserting-and-Deleting-in-Sorted-Containers-1">Inserting &amp; Deleting in Sorted Containers</a></li><li><a class="toctext" href="#Iteration-Over-Sorted-Containers-1">Iteration Over Sorted Containers</a></li><li><a class="toctext" href="#Cautionary-note-on-mutable-keys-1">Cautionary note on mutable keys</a></li><li><a class="toctext" href="#Performance-of-Sorted-Containers-1">Performance of Sorted Containers</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="sorted_containers.html">Sorted Containers</a></li></ul><a class="edit-page" href="https://github.com/JuliaCollections/DataStructures.jl/blob/master/docs/src/sorted_containers.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Sorted Containers</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Sorted-Containers-1" href="#Sorted-Containers-1">Sorted Containers</a></h1><p>Three sorted containers are provided: SortedDict, SortedMultiDict and SortedSet. <em>SortedDict</em> is similar to the built-in Julia type <code>Dict</code> with the additional feature that the keys are stored in sorted order and can be efficiently iterated in this order. SortedDict is a subtype of Associative. It is generally slower than <code>Dict</code> because looking up a key requires an O(log <em>n</em>) tree search rather than an expected O(1) hash-table lookup time as with Dict. SortedDict is a parametrized type with three parameters, the key type <code>K</code>, the value type <code>V</code>, and the ordering type <code>O</code>. SortedSet has only keys; it is an alternative to the built-in <code>Set</code> container. Internally, SortedSet is implemented as a SortedDict in which the value type is <code>Void</code>. Finally, SortedMultiDict is similar to SortedDict except that each key can be associated with multiple values. The key=&gt;value pairs in a SortedMultiDict are stored according to the sorted order for keys, and key=&gt;value pairs with the same key are stored in order of insertion.</p><p>The containers internally use a 2-3 tree, which is a kind of balanced tree and is described in many elementary data structure textbooks.</p><p>The containers require two functions to compare keys: a <em>less-than</em> and <em>equals</em> function. With the default ordering argument, the comparison functions are <code>isless(key1,key2)</code> (true when <code>key1 &lt; key2</code>) and <code>isequal(key1,key2)</code> (true when <code>key1 == key2</code>) where <code>key1</code> and <code>key2</code> are keys. More details are provided below.</p><h2><a class="nav-anchor" id="Tokens-for-Sorted-Containers-1" href="#Tokens-for-Sorted-Containers-1">Tokens for Sorted Containers</a></h2><p>The sorted container objects use a special type for indexing called a <em>token</em> defined as a two-entry tuple and aliased as <code>SDToken</code>, <code>SMDToken</code>, and <code>SetToken</code> for SortedDict, SortedMultiDict and SortedSet respectively. A token is the address of a single data item in the container and can be dereferenced in time O(1).</p><p>The first entry of a Token tuple is the container as a whole, and the second refers to the particular item. The second part is called a <em>semitoken</em>. The types for a semitoken are <code>SDSemiToken</code>, <code>SMDSemiToken</code>, and <code>SetSemiToken</code> for the three types of containers SortedDict, SortedMultiDict and SortedSet. These types are all aliases of <code>IntSemiToken</code>.</p><p>A restriction for the sorted containers is that <code>IntSemiToken</code> or its aliases cannot used as the key-type. This is because ambiguity would result between the two subscripting calls <code>sc[k]</code> and <code>sc[st]</code> described below. In the rare scenario that a sorted container whose key-type is <code>IntSemiToken</code> is required, a workaround is to wrap the key inside another immutable structure.</p><p>In the current version of Julia, it is costly to operate on tuples whose entries are not bits-types because such tuples are allocated on the heap. For example, the first entry of a token is a pointer to a container (a non-bits type), so a new token is allocated on the heap rather than the stack. In order to avoid performance loss, the package uses tokens less frequently than semitokens. For a function taking a token as an argument like <code>deref</code> described below, if it is invoked by explicitly naming the token like this:</p><pre><code class="language-julia">tok = (sc,st)   # sc is a sorted container, st is a semitoken
k,v = deref(tok)</code></pre><p>then there may be a loss of performance compared to:</p><pre><code class="language-julia">k,v = deref((sc,st))</code></pre><p>because the former needs an extra heap allocation step for <code>tok</code>.</p><p>The notion of token is similar to the concept of iterators used by C++ standard containers. Tokens can be explicitly advanced or regressed through the data in the sorted order; they are implicitly advanced or regressed via iteration loops defined below.</p><p>A token may take two special values: the <em>before-start</em> value and the <em>past-end</em> value. These values act as lower and upper bounds on the actual data. The before-start token can be advanced, while the past-end token can be regressed. A dereferencing operation on either leads to an error.</p><p>In the current implementation, semitokens are internally stored as integers. However, for the purpose of future compatibility, the user should not extract this internal representation; these integers do not have a documented interpretation in terms of the container.</p><h2><a class="nav-anchor" id="Constructors-for-Sorted-Containers-1" href="#Constructors-for-Sorted-Containers-1">Constructors for Sorted Containers</a></h2><h3><a class="nav-anchor" id="SortedDict-constructors-1" href="#SortedDict-constructors-1"><code>SortedDict</code> constructors</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataStructures.SortedDict-Union{Tuple{Ord}, Tuple{Ord}} where Ord&lt;:Base.Order.Ordering" href="#DataStructures.SortedDict-Union{Tuple{Ord}, Tuple{Ord}} where Ord&lt;:Base.Order.Ordering"><code>DataStructures.SortedDict</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">SortedDict(o=Forward)</code></pre><p>Construct an empty <code>SortedDict</code> with key type <code>K</code> and value type <code>V</code>. If <code>K</code> and <code>V</code> are not specified, the dictionary defaults to a <code>SortedDict{Any,Any}</code>. Keys and values are converted to the given type upon insertion. Ordering <code>o</code> defaults to <code>Forward</code> ordering.</p><p><strong>Note that a key type of <code>Any</code> or any other abstract type will lead to slow performance, as the values are stored boxed (i.e., as pointers), and insertion will require a run-time lookup of the appropriate comparison function. It is recommended to always specify a concrete key type, or to use one of the constructors below in which the key type is inferred.</strong></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_dict.jl#L52-L66">source</a></section><pre><code class="language-none">SortedDict{K,V}(o=Forward)</code></pre><p>Construct an empty <code>SortedDict</code> with key type <code>K</code> and value type <code>V</code> with <code>o</code> ordering (default to forward ordering).</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataStructures.SortedDict-Union{Tuple{D}, Tuple{K}, Tuple{Ord}, Tuple{Ord}} where Ord&lt;:Base.Order.Ordering where D where K" href="#DataStructures.SortedDict-Union{Tuple{D}, Tuple{K}, Tuple{Ord}, Tuple{Ord}} where Ord&lt;:Base.Order.Ordering where D where K"><code>DataStructures.SortedDict</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">SortedDict(iter, o=Forward)</code></pre><p>and <code>SortedDict{K,V}(iter, o=Forward)</code></p><p>Construct a <code>SortedDict</code> from an arbitrary iterable object of <code>key=&gt;value</code> pairs. If <code>K</code> and <code>V</code> are not specified, the key type and value type are inferred from the given iterable. The ordering object <code>o</code> defaults to <code>Forward</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_dict.jl#L110-L118">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataStructures.SortedDict-Tuple{Vararg{Pair,N} where N}" href="#DataStructures.SortedDict-Tuple{Vararg{Pair,N} where N}"><code>DataStructures.SortedDict</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">SortedDict(k1=&gt;v1, k2=&gt;v2, ...)</code></pre><p>and <code>SortedDict{K,V}(k1=&gt;v1, k2=&gt;v2, ...)</code></p><p>Construct a <code>SortedDict</code> from the given key-value pairs. If <code>K</code> and <code>V</code> are not specified, key type and value type are inferred from the given key-value pairs, and ordering is assumed to be <code>Forward</code> ordering.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_dict.jl#L71-L79">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataStructures.SortedDict-Union{Tuple{D}, Tuple{K}, Tuple{Ord,Vararg{Pair,N} where N}, Tuple{Ord}} where Ord&lt;:Base.Order.Ordering where D where K" href="#DataStructures.SortedDict-Union{Tuple{D}, Tuple{K}, Tuple{Ord,Vararg{Pair,N} where N}, Tuple{Ord}} where Ord&lt;:Base.Order.Ordering where D where K"><code>DataStructures.SortedDict</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">SortedDict{K,V}(o, k1=&gt;v1, k2=&gt;v2, ...)</code></pre><p>Construct a <code>SortedDict</code> from the given pairs with the specified ordering <code>o</code>. If <code>K</code> and <code>V</code> are not specified, the key type and value type are inferred from the given pairs. See below for more information about ordering.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_dict.jl#L92-L99">source</a></section><h3><a class="nav-anchor" id="SortedMultiDict-constructors-1" href="#SortedMultiDict-constructors-1"><code>SortedMultiDict</code> constructors</a></h3><pre><code class="language-none">SortedMultiDict(ks, vs, o)</code></pre><p>Construct a SortedMultiDict using keys given by <code>ks</code>, values given by <code>vs</code> and ordering object <code>o</code>. The ordering object defaults to <code>Forward</code> if not specified. The two arguments <code>ks</code> and <code>vs</code> are 1-dimensional arrays of the same length in which <code>ks</code> holds keys and <code>vs</code> holds the corresponding values.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataStructures.SortedMultiDict-Union{Tuple{D}, Tuple{K}, Tuple{Ord}, Tuple{Ord}} where Ord where D where K" href="#DataStructures.SortedMultiDict-Union{Tuple{D}, Tuple{K}, Tuple{Ord}, Tuple{Ord}} where Ord where D where K"><code>DataStructures.SortedMultiDict</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">SortedMultiDict{K,D}(iter)</code></pre><p>Takes an arbitrary iterable object of key=&gt;value pairs with key type <code>K</code> and value type <code>D</code>. The default Forward ordering is used.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_multi_dict.jl#L91-L96">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataStructures.SortedMultiDict-Tuple{}" href="#DataStructures.SortedMultiDict-Tuple{}"><code>DataStructures.SortedMultiDict</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">SortedMultiDict()</code></pre><p>Construct an empty <code>SortedMultiDict</code> with key type <code>Any</code> and value type <code>Any</code>. Ordering defaults to <code>Forward</code> ordering.</p><p><strong>Note that a key type of <code>Any</code> or any other abstract type will lead to slow performance.</strong></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_multi_dict.jl#L39-L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataStructures.SortedMultiDict-Union{Tuple{O}, Tuple{O}} where O&lt;:Base.Order.Ordering" href="#DataStructures.SortedMultiDict-Union{Tuple{O}, Tuple{O}} where O&lt;:Base.Order.Ordering"><code>DataStructures.SortedMultiDict</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">SortedMultiDict(o)</code></pre><p>Construct an empty <code>SortedMultiDict</code> with key type <code>Any</code> and value type <code>Any</code>, ordered using <code>o</code>.</p><p><strong>Note that a key type of <code>Any</code> or any other abstract type will lead to slow performance.</strong></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_multi_dict.jl#L51-L59">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataStructures.SortedMultiDict-Tuple{Vararg{Pair,N} where N}" href="#DataStructures.SortedMultiDict-Tuple{Vararg{Pair,N} where N}"><code>DataStructures.SortedMultiDict</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">SortedMultiDict(k1=&gt;v1, k2=&gt;v2, ...)</code></pre><p>Arguments are key-value pairs for insertion into the multidict. The keys must be of the same type as one another; the values must also be of one type.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_multi_dict.jl#L63-L69">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataStructures.SortedMultiDict-Tuple{Base.Order.Ordering,Vararg{Pair,N} where N}" href="#DataStructures.SortedMultiDict-Tuple{Base.Order.Ordering,Vararg{Pair,N} where N}"><code>DataStructures.SortedMultiDict</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">SortedMultiDict(o, k1=&gt;v1, k2=&gt;v2, ...)</code></pre><p>The first argument <code>o</code> is an ordering object. The remaining arguments are key-value pairs for insertion into the multidict. The keys must be of the same type as one another; the values must also be of one type.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_multi_dict.jl#L72-L79">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataStructures.SortedMultiDict-Union{Tuple{Any}, Tuple{D}, Tuple{K}} where D where K" href="#DataStructures.SortedMultiDict-Union{Tuple{Any}, Tuple{D}, Tuple{K}} where D where K"><code>DataStructures.SortedMultiDict</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">SortedMultiDict{K,D}(iter)</code></pre><p>Takes an arbitrary iterable object of key=&gt;value pairs with key type <code>K</code> and value type <code>D</code>. The default Forward ordering is used.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_multi_dict.jl#L91-L96">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataStructures.SortedMultiDict-Union{Tuple{D}, Tuple{K}, Tuple{Ord,Any}, Tuple{Ord}} where Ord&lt;:Base.Order.Ordering where D where K" href="#DataStructures.SortedMultiDict-Union{Tuple{D}, Tuple{K}, Tuple{Ord,Any}, Tuple{Ord}} where Ord&lt;:Base.Order.Ordering where D where K"><code>DataStructures.SortedMultiDict</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">SortedMultiDict{K,D}(o, iter)</code></pre><p>Takes an arbitrary iterable object of key=&gt;value pairs with key type <code>K</code> and value type <code>D</code>. The ordering object <code>o</code> is explicitly given.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_multi_dict.jl#L99-L104">source</a></section><h3><a class="nav-anchor" id="SortedSets-constructors-1" href="#SortedSets-constructors-1"><code>SortedSets</code> constructors</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataStructures.SortedSet" href="#DataStructures.SortedSet"><code>DataStructures.SortedSet</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SortedSet(iter, o=Forward)</code></pre><p>and     <code>SortedSet{K}(iter, o=Forward)</code> and     <code>SortedSet(o, iter)</code> and     <code>SortedSet{K}(o, iter)</code></p><p>Construct a SortedSet using keys given by iterable <code>iter</code> (e.g., an array) and ordering object <code>o</code>. The ordering object defaults to <code>Forward</code> if not specified.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_set.jl#L5-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataStructures.SortedSet-Tuple{}" href="#DataStructures.SortedSet-Tuple{}"><code>DataStructures.SortedSet</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">SortedSet()</code></pre><p>Construct a <code>SortedSet{Any}</code> with <code>Forward</code> ordering.</p><p><strong>Note that a key type of <code>Any</code> or any other abstract type will lead to slow performance.</strong></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_set.jl#L32-L39">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataStructures.SortedSet-Union{Tuple{O}, Tuple{O}} where O&lt;:Base.Order.Ordering" href="#DataStructures.SortedSet-Union{Tuple{O}, Tuple{O}} where O&lt;:Base.Order.Ordering"><code>DataStructures.SortedSet</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">SortedSet(o)</code></pre><p>Construct a <code>SortedSet{Any}</code> with <code>o</code> ordering.</p><p><strong>Note that a key type of <code>Any</code> or any other abstract type will lead to slow performance.</strong></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_set.jl#L42-L49">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataStructures.SortedSet-Union{Tuple{K}, Tuple{}} where K" href="#DataStructures.SortedSet-Union{Tuple{K}, Tuple{}} where K"><code>DataStructures.SortedSet</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">SortedSet{K}()</code></pre><p>Construct a <code>SortedSet</code> of keys of type <code>K</code> with <code>Forward</code> ordering.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_set.jl#L58-L62">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataStructures.SortedSet-Union{Tuple{K}, Tuple{O}, Tuple{O}} where O&lt;:Base.Order.Ordering where K" href="#DataStructures.SortedSet-Union{Tuple{K}, Tuple{O}, Tuple{O}} where O&lt;:Base.Order.Ordering where K"><code>DataStructures.SortedSet</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">SortedSet{K}(o)</code></pre><p>Construct a <code>SortedSet</code> of keys of type <code>K</code> with ordering given according  <code>o</code> parameter.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_set.jl#L65-L70">source</a></section><h2><a class="nav-anchor" id="Complexity-of-Sorted-Containers-1" href="#Complexity-of-Sorted-Containers-1">Complexity of Sorted Containers</a></h2><p>In the list of functions below, the running time of the various operations is provided. In these running times, <em>n</em> denotes the current size (number of items) in the container at the time of the function call, and <em>c</em> denotes the time needed to compare two keys.</p><h3><a class="nav-anchor" id="Navigating-the-Containers-1" href="#Navigating-the-Containers-1">Navigating the Containers</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.getindex-Tuple{DataStructures.SortedDict,Any}" href="#Base.getindex-Tuple{DataStructures.SortedDict,Any}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">v = sd[k]</code></pre><p>Argument <code>sd</code> is a SortedDict and <code>k</code> is a key. In an expression, this retrieves the value (<code>v</code>) associated with the key (or <code>KeyError</code> if none). On the left-hand side of an assignment, this assigns or reassigns the value associated with the key. (For assigning and reassigning, see also <code>insert!</code> below.) Time: O(<em>c</em> log <em>n</em>)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_dict.jl#L185-L193">source</a></section><pre><code class="language-none">find(m::SortedDict, k_)</code></pre><pre><code class="language-none">deref((sc, st))</code></pre><p>Argument <code>(sc,st)</code> is a token (i.e., <code>sc</code> is a container and <code>st</code> is a semitoken). Note the double-parentheses in the calling syntax: the argument of <code>deref</code> is a token, which is defined to be a 2-tuple. This returns a key=&gt;value pair. pointed to by the token for SortedDict and SortedMultiDict. Note that the syntax <code>k,v=deref((sc,st))</code> is valid because Julia automatically iterates over the two entries of the Pair in order to assign <code>k</code> and <code>v</code>. For SortedSet this returns a key. Time: O(1)</p><pre><code class="language-none">deref_key((sc, st))</code></pre><p>Argument <code>(sc,st)</code> is a token for SortedMultiDict or SortedDict. This returns the key (i.e., the first half of a key=&gt;value pair) pointed to by the token. This functionality is available as plain <code>deref</code> for SortedSet. Time: O(1)</p><pre><code class="language-none">deref_value((sc, st))</code></pre><p>Argument <code>(sc,st)</code> is a token for SortedMultiDict or SortedDict. This returns the value (i.e., the second half of a key=&gt;value pair) pointed to by the token. Time: O(1)</p><pre><code class="language-none">startof(sc)</code></pre><p>Argument <code>sc</code> is SortedDict, SortedMultiDict or SortedSet. This function returns the semitoken of the first item according to the sorted order in the container. If the container is empty, it returns the past-end semitoken. Time: O(log <em>n</em>)</p><pre><code class="language-none">endof(sc)</code></pre><p>Argument <code>sc</code> is a SortedDict, SortedMultiDict or SortedSet. This function returns the semitoken of the last item according to the sorted order in the container. If the container is empty, it returns the before-start semitoken. Time: O(log <em>n</em>)</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.first-Tuple{DataStructures.SortedDict}" href="#Base.first-Tuple{DataStructures.SortedDict}"><code>Base.first</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">first(sc)</code></pre><p>Argument <code>sc</code> is a SortedDict, SortedMultiDict or SortedSet. This function returns the first item (a <code>k=&gt;v</code> pair for SortedDict and SortedMultiDict or a key for SortedSet) according to the sorted order in the container. Thus, <code>first(sc)</code> is equivalent to <code>deref((sc,startof(sc)))</code>. It is an error to call this function on an empty container. Time: O(log <em>n</em>)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_dict.jl#L348-L357">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.first-Tuple{DataStructures.SortedMultiDict}" href="#Base.first-Tuple{DataStructures.SortedMultiDict}"><code>Base.first</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">first(sc)</code></pre><p>Argument <code>sc</code> is a SortedDict, SortedMultiDict or SortedSet. This function returns the first item (a <code>k=&gt;v</code> pair for SortedDict and SortedMultiDict or a key for SortedSet) according to the sorted order in the container. Thus, <code>first(sc)</code> is equivalent to <code>deref((sc,startof(sc)))</code>. It is an error to call this function on an empty container. Time: O(log <em>n</em>)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_multi_dict.jl#L192-L201">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.first-Tuple{DataStructures.SortedSet}" href="#Base.first-Tuple{DataStructures.SortedSet}"><code>Base.first</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">first(sc)</code></pre><p>Argument <code>sc</code> is a SortedDict, SortedMultiDict or SortedSet. This function returns the first item (a <code>k=&gt;v</code> pair for SortedDict and SortedMultiDict or a key for SortedSet) according to the sorted order in the container. Thus, <code>first(sc)</code> is equivalent to <code>deref((sc,startof(sc)))</code>. It is an error to call this function on an empty container. Time: O(log <em>n</em>)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_set.jl#L139-L148">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.last-Tuple{DataStructures.SortedDict}" href="#Base.last-Tuple{DataStructures.SortedDict}"><code>Base.last</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">last(sc)</code></pre><p>Argument <code>sc</code> is a SortedDict, SortedMultiDict or SortedSet. This function returns the last item (a <code>k=&gt;v</code> pair for SortedDict and SortedMultiDict or a key for SortedSet) according to the sorted order in the container. Thus, <code>last(sc)</code> is equivalent to <code>deref((sc,lastindex(sc)))</code>. It is an error to call this function on an empty container. Time: O(log <em>n</em>)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_dict.jl#L364-L373">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.last-Tuple{DataStructures.SortedMultiDict}" href="#Base.last-Tuple{DataStructures.SortedMultiDict}"><code>Base.last</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">last(sc)</code></pre><p>Argument <code>sc</code> is a SortedDict, SortedMultiDict or SortedSet. This function returns the last item (a <code>k=&gt;v</code> pair for SortedDict and SortedMultiDict or a key for SortedSet) according to the sorted order in the container. Thus, <code>last(sc)</code> is equivalent to <code>deref((sc,lastindex(sc)))</code>. It is an error to call this function on an empty container. Time: O(log <em>n</em>)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_multi_dict.jl#L208-L217">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.last-Tuple{DataStructures.SortedSet}" href="#Base.last-Tuple{DataStructures.SortedSet}"><code>Base.last</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">last(sc)</code></pre><p>Argument <code>sc</code> is a SortedDict, SortedMultiDict or SortedSet. This function returns the last item (a <code>k=&gt;v</code> pair for SortedDict and SortedMultiDict or a key for SortedSet) according to the sorted order in the container. Thus, <code>last(sc)</code> is equivalent to <code>deref((sc,lastindex(sc)))</code>. It is an error to call this function on an empty container. Time: O(log <em>n</em>)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_set.jl#L155-L164">source</a></section><pre><code class="language-none">pastendsemitoken(sc)</code></pre><p>Argument <code>sc</code> is a SortedDict, SortedMultiDict or SortedSet. This function returns the past-end semitoken. Time: O(1)</p><pre><code class="language-none">beforestartsemitoken(sc)</code></pre><p>Argument <code>sc</code> is a SortedDict, SortedMultiDict or SortedSet. This function returns the before-start semitoken. Time: O(1)</p><pre><code class="language-none">advance((sc,st))</code></pre><p>Argument <code>(sc,st)</code> is a token. This function returns the semitoken of the next entry in the container according to the sort order of the keys. After the last item, this routine returns the past-end semitoken. It is an error to invoke this function if <code>(sc,st)</code> is the past-end token. If <code>(sc,st)</code> is the before-start token, then this routine returns the semitoken of the first item in the sort order (i.e., the same semitoken returned by the <code>startof</code> function). Time: O(log <em>n</em>)</p><pre><code class="language-none">regress((sc,st))</code></pre><p>Argument <code>(sc,st)</code> is a token. This function returns the semitoken of the previous entry in the container according to the sort order of the keys. If <code>(sc,st)</code> indexes the first item, this routine returns the before-start semitoken. It is an error to invoke this function if <code>(sc,st)</code> is the before-start token. If <code>(sc,st)</code> is the past-end token, then this routine returns the smitoken of the last item in the sort order (i.e., the same semitoken returned by the <code>endof</code> function). Time: O(log <em>n</em>)</p><pre><code class="language-none">searchsortedfirst(sc,k)</code></pre><p>Argument <code>sc</code> is a SortedDict, SortedMultiDict or SortedSet and <code>k</code> is a key. This routine returns the semitoken of the first item in the container whose key is greater than or equal to <code>k</code>. If there is no such key, then the past-end semitoken is returned. Time: O(<em>c</em> log <em>n</em>)</p><pre><code class="language-none">searchsortedlast(sc,k)</code></pre><p>Argument <code>sc</code> is a SortedDict, SortedMultiDict or SortedSet and <code>k</code> is a key. This routine returns the semitoken of the last item in the container whose key is less than or equal to <code>k</code>. If there is no such key, then the before-start semitoken is returned. Time: O(<em>c</em> log <em>n</em>)</p><pre><code class="language-none">searchsortedafter(sc,k)</code></pre><p>Argument <code>sc</code> is a SortedDict, SortedMultiDict or SortedSet and <code>k</code> is an element of the key type. This routine returns the semitoken of the first item in the container whose key is greater than <code>k</code>. If there is no such key, then the past-end semitoken is returned. Time: O(<em>c</em> log <em>n</em>)</p><pre><code class="language-none">searchequalrange(sc,k)</code></pre><p>Argument <code>sc</code> is a SortedMultiDict and <code>k</code> is an element of the key type. This routine returns a pair of semitokens; the first of the pair is the semitoken addressing the first item in the container with key <code>k</code> and the second is the semitoken addressing the last item in the container with key <code>k</code>. If no item matches the given key, then the pair (past-end-semitoken, before-start-semitoken) is returned. Time: O(<em>c</em> log <em>n</em>)</p><h2><a class="nav-anchor" id="Inserting-and-Deleting-in-Sorted-Containers-1" href="#Inserting-and-Deleting-in-Sorted-Containers-1">Inserting &amp; Deleting in Sorted Containers</a></h2><pre><code class="language-none">empty!(sc)</code></pre><p>Argument <code>sc</code> is a SortedDict, SortedMultiDict or SortedSet. This empties the container. Time: O(1).</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.insert!-Tuple{DataStructures.SortedDict,Any,Any}" href="#Base.insert!-Tuple{DataStructures.SortedDict,Any,Any}"><code>Base.insert!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">insert!(sc, k)</code></pre><p>Argument <code>sc</code> is a SortedDict or SortedMultiDict, <code>k</code> is a key and <code>v</code> is the corresponding value. This inserts the <code>(k,v)</code> pair into the container. If the key is already present in a SortedDict, this overwrites the old value. In the case of SortedMultiDict, no overwriting takes place (since SortedMultiDict allows the same key to associate with multiple values). In the case of SortedDict, the return value is a pair whose first entry is boolean and indicates whether the insertion was new (i.e., the key was not previously present) and the second entry is the semitoken of the new entry. In the case of SortedMultiDict, a semitoken is returned (but no boolean). Time: O(<em>c</em> log <em>n</em>)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_dict.jl#L256-L270">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.insert!-Tuple{DataStructures.SortedMultiDict,Any,Any}" href="#Base.insert!-Tuple{DataStructures.SortedMultiDict,Any,Any}"><code>Base.insert!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">insert!(sc, k)</code></pre><p>Argument <code>sc</code> is a SortedDict or SortedMultiDict, <code>k</code> is a key and <code>v</code> is the corresponding value. This inserts the <code>(k,v)</code> pair into the container. If the key is already present in a SortedDict, this overwrites the old value. In the case of SortedMultiDict, no overwriting takes place (since SortedMultiDict allows the same key to associate with multiple values). In the case of SortedDict, the return value is a pair whose first entry is boolean and indicates whether the insertion was new (i.e., the key was not previously present) and the second entry is the semitoken of the new entry. In the case of SortedMultiDict, a semitoken is returned (but no boolean). Time: O(<em>c</em> log <em>n</em>)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_multi_dict.jl#L152-L166">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.insert!-Tuple{DataStructures.SortedSet,Any}" href="#Base.insert!-Tuple{DataStructures.SortedSet,Any}"><code>Base.insert!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">insert!(sc, k)</code></pre><p>Argument <code>sc</code> is a SortedSet and <code>k</code> is a key. This inserts the key into the container. If the key is already present, this overwrites the old value. (This is not necessarily a no-op; see below for remarks about the customizing the sort order.) The return value is a pair whose first entry is boolean and indicates whether the insertion was new (i.e., the key was not previously present) and the second entry is the semitoken of the new entry. Time: O(<em>c</em> log <em>n</em>)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_set.jl#L103-L113">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.push!-Tuple{DataStructures.SortedSet,Any}" href="#Base.push!-Tuple{DataStructures.SortedSet,Any}"><code>Base.push!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">push!(sc, k)</code></pre><p>Argument <code>sc</code> is a SortedSet and <code>k</code> is a key. This inserts the key into the container. If the key is already present, this overwrites the old value. (This is not necessarily a no-op; see below for remarks about the customizing the sort order.) The return value is <code>sc</code>. Time: O(<em>c</em> log <em>n</em>)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_set.jl#L120-L128">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.push!-Tuple{DataStructures.SortedDict,Pair}" href="#Base.push!-Tuple{DataStructures.SortedDict,Pair}"><code>Base.push!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">push!(sc, k=&gt;v)</code></pre><p>Argument <code>sc</code> is a SortedDict or SortedMultiDict and <code>k=&gt;v</code> is a key-value pair. This inserts the key-value pair into the container. If the key is already present, this overwrites the old value. The return value is <code>sc</code>. Time: O(<em>c</em> log <em>n</em>)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_dict.jl#L217-L224">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.push!-Tuple{DataStructures.SortedMultiDict,Pair}" href="#Base.push!-Tuple{DataStructures.SortedMultiDict,Pair}"><code>Base.push!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">push!(sc, k=&gt;v)</code></pre><p>Argument <code>sc</code> is a SortedDict or SortedMultiDict and <code>k=&gt;v</code> is a key-value pair. This inserts the key-value pair into the container. If the key is already present, this overwrites the old value. The return value is <code>sc</code>. Time: O(<em>c</em> log <em>n</em>)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_multi_dict.jl#L173-L180">source</a></section><pre><code class="language-none">delete!((sc, st))</code></pre><p>Argument <code>(sc,st)</code> is a token for a SortedDict, SortedMultiDict or SortedSet. This operation deletes the item addressed by <code>(sc,st)</code>. It is an error to call this on an entry that has already been deleted or on the before-start or past-end tokens. After this operation is complete, <code>(sc,st)</code> is an invalid token and cannot be used in any further operations. Time: O(log <em>n</em>)</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.pop!-Tuple{DataStructures.SortedDict,Any}" href="#Base.pop!-Tuple{DataStructures.SortedDict,Any}"><code>Base.pop!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">pop!(sc, k)</code></pre><p>Deletes the item with key <code>k</code> in SortedDict or SortedSet <code>sc</code> and returns the value that was associated with <code>k</code> in the case of SortedDict or <code>k</code> itself in the case of SortedSet. A <code>KeyError</code> results if <code>k</code> is not in <code>sc</code>. Time: O(<em>c</em> log <em>n</em>)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_dict.jl#L464-L471">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.pop!-Tuple{DataStructures.SortedSet,Any}" href="#Base.pop!-Tuple{DataStructures.SortedSet,Any}"><code>Base.pop!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">pop!(sc, k)</code></pre><p>Deletes the item with key <code>k</code> in SortedDict or SortedSet <code>sc</code> and returns the value that was associated with <code>k</code> in the case of SortedDict or <code>k</code> itself in the case of SortedSet. A <code>KeyError</code> results if <code>k</code> is not in <code>sc</code>. Time: O(<em>c</em> log <em>n</em>)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_set.jl#L239-L246">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.pop!-Tuple{DataStructures.SortedSet}" href="#Base.pop!-Tuple{DataStructures.SortedSet}"><code>Base.pop!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">pop!(ss)</code></pre><p>Deletes the item with first key in SortedSet <code>ss</code> and returns the key. A <code>BoundsError</code> results if <code>ss</code> is empty. Time: O(<em>c</em> log <em>n</em>)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_set.jl#L256-L261">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.setindex!-Tuple{DataStructures.SortedDict,Any,Any}" href="#Base.setindex!-Tuple{DataStructures.SortedDict,Any,Any}"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">setindex!(collection, value, key...)</code></pre><p>Store the given value at the given key or index within a collection. The syntax <code>a[i,j,...] = x</code> is converted by the compiler to <code>(setindex!(a, x, i, j, ...); x)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2295-L2300">source</a><div><pre><code class="language-none">sc[st] = v</code></pre><p>If <code>st</code> is a semitoken and <code>sc</code> is a SortedDict or SortedMultiDict, then <code>sc[st]</code> refers to the value field of the (key,value) pair that the full token <code>(sc,st)</code> refers to. This expression may occur on either side of an assignment statement. Time: O(1)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_dict.jl#L203-L210">source</a></section><h3><a class="nav-anchor" id="Token-Manipulation-1" href="#Token-Manipulation-1">Token Manipulation</a></h3><pre><code class="language-none">compare(sc, st1, st2)</code></pre><p>Here, <code>st1</code> and <code>st2</code> are semitokens for the same container <code>sc</code>; this function determines the relative positions of the data items indexed by <code>(sc,st1)</code> and <code>(sc,st2)</code> in the sorted order. The return value is -1 if <code>(sc,st1)</code> precedes <code>(sc,st2)</code>, 0 if they are equal, and 1 if <code>(sc,st1)</code> succeeds <code>(sc,st2)</code>. This function compares the tokens by determining their relative position within the tree without dereferencing them. For SortedDict it is mostly equivalent to comparing <code>deref_key((sc,st1))</code> to <code>deref_key((sc,st2))</code> using the ordering of the SortedDict except in the case that either <code>(sc,st1)</code> or <code>(sc,st2)</code> is the before-start or past-end token, in which case the <code>deref</code> operation will fail. Which one is more efficient depends on the time-complexity of comparing two keys. Similarly, for SortedSet it is mostly equivalent to comparing <code>deref((sc,st1))</code> to <code>deref((sc,st2))</code>. For SortedMultiDict, this function is not equivalent to a key comparison since two items in a SortedMultiDict with the same key are not necessarily the same item. Time: O(log <em>n</em>)</p><pre><code class="language-none">status((sc, st))</code></pre><p>This function returns 0 if the token <code>(sc,st)</code> is invalid (e.g., refers to a deleted item), 1 if the token is valid and points to data, 2 if the token is the before-start token and 3 if it is the past-end token. Time: O(1)</p><h2><a class="nav-anchor" id="Iteration-Over-Sorted-Containers-1" href="#Iteration-Over-Sorted-Containers-1">Iteration Over Sorted Containers</a></h2><p>As is standard in Julia, iteration over the containers is implemented via calls to three functions, <code>start</code>, <code>next</code> and <code>done</code>. It is usual practice, however, to call these functions implicitly with a for-loop rather than explicitly, so they are presented here in for-loop notation. Internally, all of these iterations are implemented with semitokens that are advanced via the <code>advance</code> operation. Each iteration of these loops requires O(log <em>n</em>) operations to advance the semitoken. If one loops over an entire container, then the amortized cost of advancing the semitoken drops to O(1).</p><p>The following snippet loops over the entire container <code>sc</code>, where <code>sc</code> is a SortedDict or SortedMultiDict:</p><pre><code class="language-julia">for (k,v) in sc
   &lt; body &gt;
end</code></pre><p>In this loop, <code>(k,v)</code> takes on successive (key,value) pairs according to the sort order of the key. If one uses:</p><pre><code class="language-julia">for p in sc
   &lt; body &gt;
end</code></pre><p>where <code>sc</code> is a SortedDict or SortedMultiDict, then <code>p</code> is a <code>k=&gt;v</code> pair.</p><p>For SortedSet one uses:</p><pre><code class="language-julia">for k in ss
   &lt; body &gt;
end</code></pre><p>There are two ways to iterate over a subrange of a container. The first is the inclusive iteration for SortedDict and SortedMultiDict:</p><pre><code class="language-julia">for (k,v) in inclusive(sc,st1,st2)
  &lt; body &gt;
end</code></pre><p>Here, <code>st1</code> and <code>st2</code> are semitokens that refer to the container <code>sc</code>. It is acceptable for <code>(sc,st1)</code> to be the past-end token or <code>(sc,st2)</code> to be the before-start token (in these cases, the body is not executed). If <code>compare(sc,st1,st2)==1</code> then the body is not executed. A second calling format for <code>inclusive</code> is <code>inclusive(sc,(st1,st2))</code>. One purpose for second format is so that the return value of <code>searchequalrange</code> may be used directly as the second argument to <code>inclusive</code>.</p><p>One can also define a loop that excludes the final item:</p><pre><code class="language-julia">for (k,v) in exclusive(sc,st1,st2)
  &lt; body &gt;
end</code></pre><p>In this case, all the data addressed by tokens from <code>(sc,st1)</code> up to but excluding <code>(sc,st2)</code> are executed. The body is not executed at all if <code>compare(sc,st1,st2)&gt;=0</code>. In this setting, either or both can be the past-end token, and <code>(sc,st2)</code> can be the before-start token. For the sake of consistency, <code>exclusive</code> also supports the calling format <code>exclusive(sc,(st1,st2))</code>. In the previous few snippets, if the loop object is <code>p</code> instead of <code>(k,v)</code>, then <code>p</code> is a <code>k=&gt;v</code> pair.</p><p>Both the <code>inclusive</code> and <code>exclusive</code> functions return objects that can be saved and used later for iteration. The validity of the tokens is not checked until the loop initiates.</p><p>For SortedSet the usage is:</p><pre><code class="language-julia">for k in inclusive(ss,st1,st2)
  &lt; body &gt;
end

for k in exclusive(ss,st1,st2)
  &lt; body &gt;
end</code></pre><p>If <code>sc</code> is a SortedDict or SortedMultiDict, one can iterate over just keys or just values:</p><pre><code class="language-julia">for k in keys(sc)
   &lt; body &gt;
end

for v in values(sc)
   &lt; body &gt;
end</code></pre><p>Finally, one can retrieve semitokens during any of these iterations. In the case of SortedDict and SortedMultiDict, one uses:</p><pre><code class="language-julia">for (st,k,v) in semitokens(sc)
    &lt; body &gt;
end

for (st,k) in semitokens(keys(sc))
    &lt; body &gt;
end

for (st,v) in semitokens(values(sc))
    &lt; body &gt;
end</code></pre><p>In each of the above three iterations, <code>st</code> is a semitoken referring to the current <code>(k,v)</code> pair. In the case of SortedSet, the following iteration may be used:</p><pre><code class="language-julia">for (st,k) in semitokens(ss)
    &lt; body &gt;
end</code></pre><p>If one wishes to retrieve only semitokens, the following may be used:</p><pre><code class="language-julia">for st in onlysemitokens(sc)
    &lt; body &gt;
end</code></pre><p>In this case, <code>sc</code> is a SortedDict, SortedMultiDict, or SortedSet. To be compatible with standard containers, the package also offers <code>eachindex</code> iteration:</p><pre><code class="language-julia">for ind in eachindex(sc)
    &lt; body &gt;
end</code></pre><p>This iteration function <code>eachindex</code> is equivalent to <code>keys</code> in the case of SortedDict. It is equivalent to <code>onlysemitokens</code> in the case of SortedMultiDict and SortedSet.</p><p>In place of <code>sc</code> in the above <code>keys</code>, <code>values</code> and <code>semitokens</code>, snippets, one could also use <code>inclusive(sc,st1,st2)</code> or <code>exclusive(sc,st1,st2)</code>. Similarly, for SortedSet, one can iterate over <code>semitokens(inclusive(ss,st1,st2))</code> or <code>semitokens(exclusive(ss,st1,st2))</code></p><p>Note that it is acceptable for the loop body in the above <code>semitokens</code> code snippets to invoke <code>delete!((sc,st))</code> or <code>delete!((ss,st))</code>. This is because the for-loop internal state variable is already advanced to the next token at the beginning of the body, so <code>st</code> is not necessarily referred to in the loop body (unless the user refers to it).</p><h3><a class="nav-anchor" id="Other-Functions-1" href="#Other-Functions-1">Other Functions</a></h3><pre><code class="language-none">isempty(sc)</code></pre><p>Returns <code>true</code> if the container is empty (no items). Time: O(1)</p><pre><code class="language-none">length(sc)</code></pre><p>Returns the length, i.e., number of items, in the container. Time: O(1)</p><pre><code class="language-docs">in(pr::Pair, m::SortedDict{K,D,Ord}) where {K,D,Ord &lt;: Ordering}</code></pre><pre><code class="language-none">in(x, iter)</code></pre><p>Returns true if <code>x</code> is in <code>iter</code>, where <code>iter</code> refers to any of the iterable objects described above in the discussion of container loops and <code>x</code> is of the appropriate type. For all of the iterables except the five listed below, the algorithm used is a linear-time search. For example, the call:</p><pre><code class="language-none">(k=&gt;v) in exclusive(sd, st1, st2)</code></pre><p>where <code>sd</code> is a SortedDict, <code>st1</code> and <code>st2</code> are semitokens, <code>k</code> is a key, and <code>v</code> is a value, will loop over all entries in the dictionary between the two tokens and a compare for equality using <code>isequal</code> between the indexed item and <code>k=&gt;v</code>.</p><p>The five exceptions are:</p><pre><code class="language-julia">(k=&gt;v) in sd
(k=&gt;v) in smd
k in ss
k in keys(sd)
k in keys(smd)</code></pre><p>Here, <code>sd</code> is a SortedDict, <code>smd</code> is a SortedMultiDict, and <code>ss</code> is a SortedSet.</p><p>These five invocations of <code>in</code> use the index structure of the sorted container and test equality based on the order object of the keys rather than <code>isequal</code>. Therefore, these five are all faster than linear-time looping. The first three were already discussed in the previous entry. The last two are equivalent to <code>haskey(sd,k)</code> and <code>haskey(smd,k)</code> respectively. To force the use of <code>isequal</code> test on the keys rather than the order object (thus slowing the execution from logarithmic to linear time), replace the above five constructs with these:</p><pre><code class="language-julia">(k=&gt;v) in collect(sd)
(k=&gt;v) in collect(smd)
k in collect(ss)
k in collect(keys(sd))
k in collect(keys(smd))</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.eltype-Tuple{DataStructures.SortedDict}" href="#Base.eltype-Tuple{DataStructures.SortedDict}"><code>Base.eltype</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">eltype(sc)</code></pre><p>Returns the (key,value) type (a 2-entry pair, i.e., <code>Pair{K,V}</code>) for SortedDict and SortedMultiDict. Returns the key type for SortedSet. This function may also be applied to the type itself. Time: O(1)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_dict.jl#L276-L282">source</a><div><pre><code class="language-none">eltype(sc)</code></pre><p>Returns the (key,value) type (a 2-entry pair, i.e., <code>Pair{K,V}</code>) for SortedDict and SortedMultiDict. Returns the key type for SortedSet. This function may also be applied to the type itself. Time: O(1)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_multi_dict.jl#L259-L265">source</a><div><pre><code class="language-none">eltype(sc)</code></pre><p>Returns the key type for SortedSet. This function may also be applied to the type itself. Time: O(1)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_set.jl#L177-L182">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.keytype-Tuple{DataStructures.SortedDict}" href="#Base.keytype-Tuple{DataStructures.SortedDict}"><code>Base.keytype</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">keytype(type)</code></pre><p>Get the key type of an associative collection type. Behaves similarly to <a href="sorted_containers.html#Base.eltype-Tuple{DataStructures.SortedDict}"><code>eltype</code></a>.</p><pre><code class="language-julia-repl">julia&gt; keytype(Dict(Int32(1) =&gt; &quot;foo&quot;))
Int32</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d386e40c17d43b79fc89d3e579fc04547241787c/base/associative.jl#L196-L205">source</a><div><pre><code class="language-none">keytype(sc)</code></pre><p>Returns the key type for SortedDict, SortedMultiDict and SortedSet. This function may also be applied to the type itself. Time: O(1)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_dict.jl#L307-L312">source</a><div><pre><code class="language-none">keytype(sc)</code></pre><p>Returns the key type for SortedDict, SortedMultiDict and SortedSet. This function may also be applied to the type itself. Time: O(1)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_multi_dict.jl#L287-L292">source</a><div><pre><code class="language-none">keytype(sc)</code></pre><p>Returns the key type for SortedDict, SortedMultiDict and SortedSet. This function may also be applied to the type itself. Time: O(1)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_set.jl#L186-L191">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.valtype-Tuple{DataStructures.SortedDict}" href="#Base.valtype-Tuple{DataStructures.SortedDict}"><code>Base.valtype</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">valtype(type)</code></pre><p>Get the value type of an associative collection type. Behaves similarly to <a href="sorted_containers.html#Base.eltype-Tuple{DataStructures.SortedDict}"><code>eltype</code></a>.</p><pre><code class="language-julia-repl">julia&gt; valtype(Dict(Int32(1) =&gt; &quot;foo&quot;))
String</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d386e40c17d43b79fc89d3e579fc04547241787c/base/associative.jl#L210-L219">source</a><div><pre><code class="language-none">valtype(sc)</code></pre><p>Returns the value type for SortedDict and SortedMultiDict. This function may also be applied to the type itself. Time: O(1)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_dict.jl#L316-L321">source</a><div><pre><code class="language-none">valtype(sc)</code></pre><p>Returns the value type for SortedDict and SortedMultiDict. This function may also be applied to the type itself. Time: O(1)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_multi_dict.jl#L296-L301">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataStructures.ordtype-Tuple{DataStructures.SortedDict}" href="#DataStructures.ordtype-Tuple{DataStructures.SortedDict}"><code>DataStructures.ordtype</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">ordtype(sc)</code></pre><p>Returns the order type for SortedDict, SortedMultiDict and SortedSet. This function may also be applied to the type itself. Time: O(1)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_dict.jl#L325-L331">source</a><div><pre><code class="language-none">ordtype(sc)</code></pre><p>Returns the order type for SortedDict, SortedMultiDict and SortedSet. This function may also be applied to the type itself. Time: O(1)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_multi_dict.jl#L305-L311">source</a><div><pre><code class="language-none">ordtype(sc)</code></pre><p>Returns the order type for SortedDict, SortedMultiDict and SortedSet. This function may also be applied to the type itself. Time: O(1)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_set.jl#L195-L201">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.similar-Tuple{DataStructures.SortedDict}" href="#Base.similar-Tuple{DataStructures.SortedDict}"><code>Base.similar</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">similar(array, [element_type=eltype(array)], [dims=size(array)])</code></pre><p>Create an uninitialized mutable array with the given element type and size, based upon the given source array. The second and third arguments are both optional, defaulting to the given array&#39;s <code>eltype</code> and <code>size</code>. The dimensions may be specified either as a single tuple argument or as a series of integer arguments.</p><p>Custom AbstractArray subtypes may choose which specific array type is best-suited to return for the given element type and dimensionality. If they do not specialize this method, the default is an <code>Array{element_type}(dims...)</code>.</p><p>For example, <code>similar(1:10, 1, 4)</code> returns an uninitialized <code>Array{Int,2}</code> since ranges are neither mutable nor support 2 dimensions:</p><pre><code class="language-julia-repl">julia&gt; similar(1:10, 1, 4)
1×4 Array{Int64,2}:
 4419743872  4374413872  4419743888  0</code></pre><p>Conversely, <code>similar(trues(10,10), 2)</code> returns an uninitialized <code>BitVector</code> with two elements since <code>BitArray</code>s are both mutable and can support 1-dimensional arrays:</p><pre><code class="language-julia-repl">julia&gt; similar(trues(10,10), 2)
2-element BitArray{1}:
 false
 false</code></pre><p>Since <code>BitArray</code>s can only store elements of type <a href="@ref"><code>Bool</code></a>, however, if you request a different element type it will create a regular <code>Array</code> instead:</p><pre><code class="language-julia-repl">julia&gt; similar(falses(10), Float64, 2, 4)
2×4 Array{Float64,2}:
 2.18425e-314  2.18425e-314  2.18425e-314  2.18425e-314
 2.18425e-314  2.18425e-314  2.18425e-314  2.18425e-314</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L478-L519">source</a><div><pre><code class="language-none">similar(sc)</code></pre><p>Returns a new SortedDict, SortedMultiDict, or SortedSet of the same type and with the same ordering as <code>sc</code> but with no entries (i.e., empty). Time: O(1)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_dict.jl#L604-L610">source</a><div><pre><code class="language-none">similar(sc)</code></pre><p>Returns a new SortedDict, SortedMultiDict, or SortedSet of the same type and with the same ordering as <code>sc</code> but with no entries (i.e., empty). Time: O(1)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_multi_dict.jl#L471-L477">source</a><div><pre><code class="language-none">similar(sc)</code></pre><p>Returns a new SortedDict, SortedMultiDict, or SortedSet of the same type and with the same ordering as <code>sc</code> but with no entries (i.e., empty). Time: O(1)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_set.jl#L558-L564">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataStructures.orderobject-Tuple{DataStructures.SortedDict}" href="#DataStructures.orderobject-Tuple{DataStructures.SortedDict}"><code>DataStructures.orderobject</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">orderobject(sc)</code></pre><p>Returns the order object used to construct the container. Time: O(1)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_dict.jl#L336-L340">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.haskey-Tuple{DataStructures.SortedDict,Any}" href="#Base.haskey-Tuple{DataStructures.SortedDict,Any}"><code>Base.haskey</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">haskey(sc,k)</code></pre><p>Returns true if key <code>k</code> is present for SortedDict, SortedMultiDict or SortedSet <code>sc</code>. For SortedSet, <code>haskey(sc,k)</code> is a synonym for <code>in(k,sc)</code>. For SortedDict and SortedMultiDict, <code>haskey(sc,k)</code> is equivalent to <code>in(k,keys(sc))</code>. Time: O(<em>c</em> log <em>n</em>)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_dict.jl#L380-L387">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.get-Tuple{DataStructures.SortedDict,Any,Any}" href="#Base.get-Tuple{DataStructures.SortedDict,Any,Any}"><code>Base.get</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">get(collection, key, default)</code></pre><p>Return the value stored for the given key, or the given default value if no mapping for the key is present.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; d = Dict(&quot;a&quot;=&gt;1, &quot;b&quot;=&gt;2);

julia&gt; get(d, &quot;a&quot;, 3)
1

julia&gt; get(d, &quot;c&quot;, 3)
3</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1418-L1434">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.get!-Tuple{DataStructures.SortedDict,Any,Any}" href="#Base.get!-Tuple{DataStructures.SortedDict,Any,Any}"><code>Base.get!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">get!(collection, key, default)</code></pre><p>Return the value stored for the given key, or if no mapping for the key is present, store <code>key =&gt; default</code>, and return <code>default</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; d = Dict(&quot;a&quot;=&gt;1, &quot;b&quot;=&gt;2, &quot;c&quot;=&gt;3);

julia&gt; get!(d, &quot;a&quot;, 5)
1

julia&gt; get!(d, &quot;d&quot;, 4)
4

julia&gt; d
Dict{String,Int64} with 4 entries:
  &quot;c&quot; =&gt; 3
  &quot;b&quot; =&gt; 2
  &quot;a&quot; =&gt; 1
  &quot;d&quot; =&gt; 4</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1947-L1970">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.getkey-Tuple{DataStructures.SortedDict,Any,Any}" href="#Base.getkey-Tuple{DataStructures.SortedDict,Any,Any}"><code>Base.getkey</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">getkey(sd,k,defaultk)</code></pre><p>Returns key <code>k</code> where <code>sd</code> is a SortedDict, if <code>k</code> is in <code>sd</code> else it returns <code>defaultk</code>. If the container uses in its ordering an <code>eq</code> method different from isequal (e.g., case-insensitive ASCII strings illustrated below), then the return value is the actual key stored in the SortedDict that is equivalent to <code>k</code> according to the <code>eq</code> method, which might not be equal to <code>k</code>. Similarly, if the user performs an implicit conversion as part of the call (e.g., the container has keys that are floats, but the <code>k</code> argument to <code>getkey</code> is an Int), then the returned key is the actual stored key rather than <code>k</code>. Time: O(<em>c</em> log <em>n</em>)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_dict.jl#L427-L440">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isequal-Tuple{DataStructures.SortedDict,DataStructures.SortedDict}" href="#Base.isequal-Tuple{DataStructures.SortedDict,DataStructures.SortedDict}"><code>Base.isequal</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">isequal(sc1,sc2)</code></pre><p>Checks if two containers are equal in the sense that they contain the same items; the keys are compared using the <code>eq</code> method, while the values are compared with the <code>isequal</code> function. In the case of SortedMultiDict, equality requires that the values associated with a particular key have same order (that is, the same insertion order). Note that <code>isequal</code> in this sense does not imply any correspondence between semitokens for items in <code>sc1</code> with those for <code>sc2</code>. If the equality-testing method associated with the keys and values implies hash-equivalence in the case of SortedDict, then <code>isequal</code> of the entire containers implies hash-equivalence of the containers. Time: O(<em>cn</em> + <em>n</em> log <em>n</em>)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_dict.jl#L484-L498">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataStructures.packcopy-Tuple{DataStructures.SortedDict}" href="#DataStructures.packcopy-Tuple{DataStructures.SortedDict}"><code>DataStructures.packcopy</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">packcopy(sc)</code></pre><p>This returns a copy of <code>sc</code> in which the data is packed. When deletions take place, the previously allocated memory is not returned. This function can be used to reclaim memory after many deletions. Time: O(<em>cn</em> log <em>n</em>)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_dict.jl#L531-L538">source</a><div><pre><code class="language-none">packcopy(sc)</code></pre><p>This returns a copy of <code>sc</code> in which the data is packed. When deletions take place, the previously allocated memory is not returned. This function can be used to reclaim memory after many deletions. Time: O(<em>cn</em> log <em>n</em>)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_multi_dict.jl#L388-L395">source</a><div><pre><code class="language-none">packcopy(sc)</code></pre><p>This returns a copy of <code>sc</code> in which the data is packed. When deletions take place, the previously allocated memory is not returned. This function can be used to reclaim memory after many deletions. Time: O(<em>cn</em> log <em>n</em>)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_set.jl#L512-L519">source</a></section><pre><code class="language-none">deepcopy(sc)</code></pre><p>This returns a copy of <code>sc</code> in which the data is deep-copied, i.e., the keys and values are replicated if they are mutable types. A semitoken for the original <code>sc</code> is a valid semitoken for the copy because this operation preserves the relative positions of the data in memory. Time O(<em>maxn</em>), where <em>maxn</em> denotes the maximum size that <code>sc</code> has attained in the past.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataStructures.packdeepcopy-Tuple{Any}" href="#DataStructures.packdeepcopy-Tuple{Any}"><code>DataStructures.packdeepcopy</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">packdeepcopy(sc)</code></pre><p>This returns a packed copy of <code>sc</code> in which the keys and values are deep-copied. This function can be used to reclaim memory after many deletions. Time: O(<em>cn</em> log <em>n</em>)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_dict.jl#L545-L551">source</a><div><pre><code class="language-none">packdeepcopy(sc)</code></pre><p>This returns a packed copy of <code>sc</code> in which the keys and values are deep-copied. This function can be used to reclaim memory after many deletions. Time: O(<em>cn</em> log <em>n</em>)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_multi_dict.jl#L402-L408">source</a><div><pre><code class="language-none">packdeepcopy(sc)</code></pre><p>This returns a packed copy of <code>sc</code> in which the keys and values are deep-copied. This function can be used to reclaim memory after many deletions. Time: O(<em>cn</em> log <em>n</em>)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_set.jl#L528-L534">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.merge-Union{Tuple{DataStructures.SortedDict{K,D,Ord},Vararg{Associative{K,D},N} where N}, Tuple{D}, Tuple{K}, Tuple{Ord}} where Ord&lt;:Base.Order.Ordering where D where K" href="#Base.merge-Union{Tuple{DataStructures.SortedDict{K,D,Ord},Vararg{Associative{K,D},N} where N}, Tuple{D}, Tuple{K}, Tuple{Ord}} where Ord&lt;:Base.Order.Ordering where D where K"><code>Base.merge</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">merge(sc1, sc2...)</code></pre><p>This returns a SortedDict or SortedMultiDict that results from merging SortedDicts or SortedMultiDicts <code>sc1</code>, <code>sc2</code>, etc., which all must have the same key-value-ordering types. In the case of keys duplicated among the arguments, the rightmost argument that owns the key gets its value stored for SortedDict. In the case of SortedMultiDict all the key-value pairs are stored, and for keys shared between <code>sc1</code> and <code>sc2</code> the ordering is left-to-right. This function is not available for SortedSet, but the <code>union</code> function (see below) provides equivalent functionality. Time: O(<em>cN</em> log <em>N</em>), where <em>N</em> is the total size of all the arguments.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_dict.jl#L582-L595">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.merge!-Union{Tuple{DataStructures.SortedDict{K,D,Ord},Vararg{Associative{K,D},N} where N}, Tuple{D}, Tuple{K}, Tuple{Ord}} where Ord&lt;:Base.Order.Ordering where D where K" href="#Base.merge!-Union{Tuple{DataStructures.SortedDict{K,D,Ord},Vararg{Associative{K,D},N} where N}, Tuple{D}, Tuple{K}, Tuple{Ord}} where Ord&lt;:Base.Order.Ordering where D where K"><code>Base.merge!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">merge!(sc, sc1...)</code></pre><p>This updates <code>sc</code> by merging SortedDicts or SortedMultiDicts <code>sc1</code>, etc. into <code>sc</code>. These must all must have the same key-value types. In the case of keys duplicated among the arguments, the rightmost argument that owns the key gets its value stored for SortedDict. In the case of SortedMultiDict all the key-value pairs are stored, and for overlapping keys the ordering is left-to-right. This function is not available for SortedSet, but the <code>union!</code> function (see below) provides equivalent functionality. Time: O(<em>cN</em> log <em>N</em>), where <em>N</em> is the total size of all the arguments.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_dict.jl#L562-L574">source</a></section><h3><a class="nav-anchor" id="Set-operations-1" href="#Set-operations-1">Set operations</a></h3><p>The SortedSet container supports the following set operations. Note that in the case of intersect, symdiff and setdiff, the two SortedSets should have the same key and ordering object. If they have different key or ordering types, no error message is produced; instead, the built-in default versions of these functions (that can be applied to <code>Any</code> iterables and that return arrays) are invoked.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.union!-Tuple{DataStructures.SortedSet,Any}" href="#Base.union!-Tuple{DataStructures.SortedSet,Any}"><code>Base.union!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">union!(ss, iterable)</code></pre><p>This function inserts each item from the second argument (which must iterable) into the SortedSet <code>ss</code>. The items must be convertible to the key-type of <code>ss</code>. Time: O(<em>ci</em> log <em>n</em>) where <em>i</em> is the number of items in the iterable argument.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_set.jl#L314-L321">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.union-Tuple{DataStructures.SortedSet,Vararg{Any,N} where N}" href="#Base.union-Tuple{DataStructures.SortedSet,Vararg{Any,N} where N}"><code>Base.union</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">union(ss, iterable...)</code></pre><p>This function creates a new SortedSet (the return argument) and inserts each item from <code>ss</code> and each item from each iterable argument into the returned SortedSet. Time: O(<em>cn</em> log <em>n</em>) where <em>n</em> is the total number of items in all the arguments.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_set.jl#L329-L336">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.intersect-Union{Tuple{DataStructures.SortedSet{K,Ord},Vararg{DataStructures.SortedSet{K,Ord},N} where N}, Tuple{K}, Tuple{Ord}} where Ord&lt;:Base.Order.Ordering where K" href="#Base.intersect-Union{Tuple{DataStructures.SortedSet{K,Ord},Vararg{DataStructures.SortedSet{K,Ord},N} where N}, Tuple{K}, Tuple{Ord}} where Ord&lt;:Base.Order.Ordering where K"><code>Base.intersect</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">intersect(ss, others...)</code></pre><p>Each argument is a SortedSet with the same key and order type. The return variable is a new SortedSet that is the intersection of all the sets that are input. Time: O(<em>cn</em> log <em>n</em>), where <em>n</em> is the total number of items in all the arguments.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_set.jl#L368-L375">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.symdiff-Union{Tuple{DataStructures.SortedSet{K,Ord},DataStructures.SortedSet{K,Ord}}, Tuple{K}, Tuple{Ord}} where Ord&lt;:Base.Order.Ordering where K" href="#Base.symdiff-Union{Tuple{DataStructures.SortedSet{K,Ord},DataStructures.SortedSet{K,Ord}}, Tuple{K}, Tuple{Ord}} where Ord&lt;:Base.Order.Ordering where K"><code>Base.symdiff</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">symdiff(ss1, ss2)</code></pre><p>The two argument are sorted sets with the same key and order type. This operation computes the symmetric difference, i.e., a sorted set containing entries that are in one of <code>ss1</code>, <code>ss2</code> but not both. Time: O(<em>cn</em> log <em>n</em>), where <em>n</em> is the total size of the two containers.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_set.jl#L394-L402">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.setdiff-Union{Tuple{DataStructures.SortedSet{K,Ord},DataStructures.SortedSet{K,Ord}}, Tuple{K}, Tuple{Ord}} where Ord&lt;:Base.Order.Ordering where K" href="#Base.setdiff-Union{Tuple{DataStructures.SortedSet{K,Ord},DataStructures.SortedSet{K,Ord}}, Tuple{K}, Tuple{Ord}} where Ord&lt;:Base.Order.Ordering where K"><code>Base.setdiff</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">setdiff(ss1, ss2)</code></pre><p>The two arguments are sorted sets with the same key and order type. This operation computes the difference, i.e., a sorted set containing entries that in are in <code>ss1</code> but not <code>ss2</code>. Time: O(<em>cn</em> log <em>n</em>), where <em>n</em> is the total size of the two containers.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_set.jl#L439-L446">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.setdiff!-Tuple{DataStructures.SortedSet,Any}" href="#Base.setdiff!-Tuple{DataStructures.SortedSet,Any}"><code>Base.setdiff!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">setdiff!(ss, iterable)</code></pre><p>This function deletes items in <code>ss</code> that appear in the second argument. The second argument must be iterable and its entries must be convertible to the key type of m1. Time: O(<em>cm</em> log <em>n</em>), where <em>n</em> is the size of <code>ss</code> and <em>m</em> is the number of items in <code>iterable</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_set.jl#L477-L485">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.issubset-Tuple{Any,DataStructures.SortedSet}" href="#Base.issubset-Tuple{Any,DataStructures.SortedSet}"><code>Base.issubset</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">issubset(iterable, ss)</code></pre><p>This function checks whether each item of the first argument is an element of the SortedSet <code>ss</code>. The entries must be convertible to the key-type of <code>ss</code>. Time: O(<em>cm</em> log <em>n</em>), where <em>n</em> is the sizes of <code>ss</code> and <em>m</em> is the number of items in <code>iterable</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaCollections/DataStructures.jl/blob/691caea3e01837b84ed74226fdf231191a1e55b6/src/sorted_set.jl#L495-L502">source</a></section><h3><a class="nav-anchor" id="Ordering-of-keys-1" href="#Ordering-of-keys-1">Ordering of keys</a></h3><p>As mentioned earlier, the default ordering of keys uses <code>isless</code> and <code>isequal</code> functions. If the default ordering is used, it is a requirement of the container that <code>isequal(a,b)</code> is true if and only if <code>!isless(a,b)</code> and <code>!isless(b,a)</code> are both true. This relationship between <code>isequal</code> and <code>isless</code> holds for common built-in types, but it may not hold for all types, especially user-defined types. If it does not hold for a certain type, then a custom ordering argument must be defined as discussed in the next few paragraphs.</p><p>The name for the default ordering (i.e., using <code>isless</code> and <code>isequal</code>) is <code>Forward</code>. Note: this is the name of the ordering object; its type is <code>ForwardOrdering.</code> Another possible ordering object is <code>Reverse</code>, which reverses the usual sorted order. This name must be imported <code>import Base.Reverse</code> if it is used.</p><p>As an example of a custom ordering, suppose the keys are of type <code>String</code>, and the user wishes to order the keys ignoring case: <em>APPLE</em>, <em>berry</em> and <em>Cherry</em> would appear in that order, and <em>APPLE</em> and <em>aPPlE</em> would be indistinguishable in this ordering.</p><p>The simplest approach is to define an ordering object of the form <code>Lt(my_isless)</code>, where <code>Lt</code> is a built-in type (see <code>ordering.jl</code>) and <code>my_isless</code> is the user&#39;s comparison function. In the above example, the ordering object would be:</p><pre><code class="language-julia">Lt((x,y) -&gt; isless(lowercase(x),lowercase(y)))</code></pre><p>The ordering object is indicated in the above list of constructors in the <code>o</code> position (see above for constructor syntax).</p><p>This approach suffers from a performance hit (10%-50% depending on the container) because the compiler cannot inline or compute the correct dispatch for the function in parentheses, so the dispatch takes place at run-time. A more complicated but higher-performance method to implement a custom ordering is as follows. First, the user creates a singleton type that is a subtype of <code>Ordering</code> as follows:</p><pre><code class="language-julia">struct CaseInsensitive &lt;: Ordering
end</code></pre><p>Next, the user defines a method named <code>lt</code> for less-than in this ordering:</p><pre><code class="language-julia">lt(::CaseInsensitive, a, b) = isless(lowercase(a), lowercase(b))</code></pre><p>The first argument to <code>lt</code> is an object of the <code>CaseInsensitive</code> type (there is only one such object since it is a singleton type). The container also needs an equal-to function; the default is:</p><pre><code class="language-julia">eq(o::Ordering, a, b) = !lt(o, a, b) &amp;&amp; !lt(o, b, a)</code></pre><p>For a further slight performance boost, the user can also customize this function with a more efficient implementation. In the above example, an appropriate customization would be:</p><pre><code class="language-julia">eq(::CaseInsensitive, a, b) = isequal(lowercase(a), lowercase(b))</code></pre><p>Finally, the user specifies the unique element of <code>CaseInsensitive</code>, namely the object <code>CaseInsensitive()</code>, as the ordering object to the <code>SortedDict</code>, <code>SortedMultiDict</code> or <code>SortedSet</code> constructor.</p><p>For the above code to work, the module must make the following declarations, typically near the beginning:</p><pre><code class="language-julia">import Base.Ordering
import Base.lt
import DataStructures.eq</code></pre><h2><a class="nav-anchor" id="Cautionary-note-on-mutable-keys-1" href="#Cautionary-note-on-mutable-keys-1">Cautionary note on mutable keys</a></h2><p>As with ordinary Dicts, keys for the sorted containers can be either mutable or immutable. In the case of mutable keys, it is important that the keys not be mutated once they are in the container else the indexing structure will be corrupted. (The same restriction applies to Dict.) For example, suppose a SortedDict <code>sd</code> is defined in which the keys are of type <code>Array{Int,1}.</code> (For this to be possible, the user must provide an <code>isless</code> function or order object for <code>Array{Int,1}</code> since none is built into Julia.) Suppose the values of <code>sd</code> are of type <code>Int</code>. Then the following sequence of statements leaves <code>sd</code> in a corrupted state:</p><pre><code class="language-julia">k = [1,2,3]
sd[k] = 19
k[1] = 7</code></pre><h2><a class="nav-anchor" id="Performance-of-Sorted-Containers-1" href="#Performance-of-Sorted-Containers-1">Performance of Sorted Containers</a></h2><p>The sorted containers are currently not optimized for cache performance. This will be addressed in the future.</p><p>There is a minor performance issue as follows: the container may hold onto a small number of keys and values even after the data records containing those keys and values have been deleted. This may cause a memory drain in the case of large keys and values. It may also lead to a delay in the invocation of finalizers. All keys and values are released completely by the <code>empty!</code> function.</p><footer><hr/><a class="previous" href="intset.html"><span class="direction">Previous</span><span class="title">DataStructures.IntSet</span></a></footer></article></body></html>
